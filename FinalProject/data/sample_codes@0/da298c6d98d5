static int adv7170_enum_mbus_code(struct v4l2_subdev *sd,	return 0;
}

static int adv7170_g_fmt(struct v4l2_subdev *sd,
				struct v4l2_mbus_framefmt *mf)
static int adv7170_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *mf = &format->format;
	u8 val = adv7170_read(sd, 0x7);

	if (format->pad)
		return -EINVAL;

	if ((val & 0x40) == (1 << 6))
		mf->code = MEDIA_BUS_FMT_UYVY8_1X16;
	else

static const struct v4l2_subdev_video_ops adv7170_video_ops = {	.s_std_output = adv7170_s_std_output,
	.s_routing = adv7170_s_routing,
	.s_mbus_fmt = adv7170_s_fmt,
	.g_mbus_fmt = adv7170_g_fmt,
};

static const struct v4l2_subdev_pad_ops adv7170_pad_ops = {
	.enum_mbus_code = adv7170_enum_mbus_code,
	.get_fmt = adv7170_get_fmt,
};

static const struct v4l2_subdev_ops adv7170_ops = {

static int adv7175_enum_mbus_code(struct v4l2_subdev *sd,	return 0;
}

static int adv7175_g_fmt(struct v4l2_subdev *sd,
				struct v4l2_mbus_framefmt *mf)
static int adv7175_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *mf = &format->format;
	u8 val = adv7175_read(sd, 0x7);

	if (format->pad)
		return -EINVAL;

	if ((val & 0x40) == (1 << 6))
		mf->code = MEDIA_BUS_FMT_UYVY8_1X16;
	else

static const struct v4l2_subdev_video_ops adv7175_video_ops = {	.s_std_output = adv7175_s_std_output,
	.s_routing = adv7175_s_routing,
	.s_mbus_fmt = adv7175_s_fmt,
	.g_mbus_fmt = adv7175_g_fmt,
};

static const struct v4l2_subdev_pad_ops adv7175_pad_ops = {
	.enum_mbus_code = adv7175_enum_mbus_code,
	.get_fmt = adv7175_get_fmt,
};

static const struct v4l2_subdev_ops adv7175_ops = {

static int adv7183_s_mbus_fmt(struct v4l2_subdev *sd,	return 0;
}

static int adv7183_g_mbus_fmt(struct v4l2_subdev *sd,
				struct v4l2_mbus_framefmt *fmt)
static int adv7183_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct adv7183 *decoder = to_adv7183(sd);

	*fmt = decoder->fmt;
	if (format->pad)
		return -EINVAL;

	format->format = decoder->fmt;
	return 0;
}


static const struct v4l2_subdev_video_ops adv7183_video_ops = {	.g_input_status = adv7183_g_input_status,
	.try_mbus_fmt = adv7183_try_mbus_fmt,
	.s_mbus_fmt = adv7183_s_mbus_fmt,
	.g_mbus_fmt = adv7183_g_mbus_fmt,
	.s_stream = adv7183_s_stream,
};

static const struct v4l2_subdev_pad_ops adv7183_pad_ops = {
	.enum_mbus_code = adv7183_enum_mbus_code,
	.get_fmt = adv7183_get_fmt,
};

static const struct v4l2_subdev_ops adv7183_ops = {

static int adv7842_enum_mbus_code(struct v4l2_subdev *sd,	return 0;
}

static int adv7842_g_mbus_fmt(struct v4l2_subdev *sd,
			      struct v4l2_mbus_framefmt *fmt)
static int adv7842_fill_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *fmt = &format->format;
	struct adv7842_state *state = to_state(sd);

	if (format->pad)
		return -EINVAL;

	fmt->width = state->timings.bt.width;
	fmt->height = state->timings.bt.height;
	fmt->code = MEDIA_BUS_FMT_FIXED;

static const struct v4l2_subdev_video_ops adv7842_video_ops = {	.s_dv_timings = adv7842_s_dv_timings,
	.g_dv_timings = adv7842_g_dv_timings,
	.query_dv_timings = adv7842_query_dv_timings,
	.g_mbus_fmt = adv7842_g_mbus_fmt,
	.try_mbus_fmt = adv7842_g_mbus_fmt,
	.s_mbus_fmt = adv7842_g_mbus_fmt,
};

static const struct v4l2_subdev_pad_ops adv7842_pad_ops = {

static const struct v4l2_subdev_pad_ops adv7842_pad_ops = {	.enum_dv_timings = adv7842_enum_dv_timings,
	.dv_timings_cap = adv7842_dv_timings_cap,
	.enum_mbus_code = adv7842_enum_mbus_code,
	.get_fmt = adv7842_fill_fmt,
	.set_fmt = adv7842_fill_fmt,
};

static const struct v4l2_subdev_ops adv7842_ops = {

static int ak881x_s_register(struct v4l2_subdev *sd,}
#endif

static int ak881x_try_g_mbus_fmt(struct v4l2_subdev *sd,
				 struct v4l2_mbus_framefmt *mf)
static int ak881x_fill_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *mf = &format->format;
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct ak881x *ak881x = to_ak881x(client);

	if (format->pad)
		return -EINVAL;

	v4l_bound_align_image(&mf->width, 0, 720, 2,
			      &mf->height, 0, ak881x->lines, 1, 0);
	mf->field	= V4L2_FIELD_INTERLACED;

static int ak881x_try_g_mbus_fmt(struct v4l2_subdev *sd,	return 0;
}

static int ak881x_s_mbus_fmt(struct v4l2_subdev *sd,
			     struct v4l2_mbus_framefmt *mf)
{
	if (mf->field != V4L2_FIELD_INTERLACED ||
	    mf->code != MEDIA_BUS_FMT_YUYV8_2X8)
		return -EINVAL;

	return ak881x_try_g_mbus_fmt(sd, mf);
}

static int ak881x_enum_mbus_code(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_mbus_code_enum *code)

static struct v4l2_subdev_core_ops ak881x_subdev_core_ops = {};

static struct v4l2_subdev_video_ops ak881x_subdev_video_ops = {
	.s_mbus_fmt	= ak881x_s_mbus_fmt,
	.g_mbus_fmt	= ak881x_try_g_mbus_fmt,
	.try_mbus_fmt	= ak881x_try_g_mbus_fmt,
	.cropcap	= ak881x_cropcap,
	.s_std_output	= ak881x_s_std_output,
	.s_stream	= ak881x_s_stream,

static struct v4l2_subdev_video_ops ak881x_subdev_video_ops = {
static const struct v4l2_subdev_pad_ops ak881x_subdev_pad_ops = {
	.enum_mbus_code = ak881x_enum_mbus_code,
	.set_fmt	= ak881x_fill_fmt,
	.get_fmt	= ak881x_fill_fmt,
};

static struct v4l2_subdev_ops ak881x_subdev_ops = {

static int ml86v7667_enum_mbus_code(struct v4l2_subdev *sd,	return 0;
}

static int ml86v7667_mbus_fmt(struct v4l2_subdev *sd,
			      struct v4l2_mbus_framefmt *fmt)
static int ml86v7667_fill_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct ml86v7667_priv *priv = to_ml86v7667(sd);
	struct v4l2_mbus_framefmt *fmt = &format->format;

	if (format->pad)
		return -EINVAL;

	fmt->code = MEDIA_BUS_FMT_YUYV8_2X8;
	fmt->colorspace = V4L2_COLORSPACE_SMPTE170M;

static struct v4l2_subdev_video_ops ml86v7667_subdev_video_ops = {	.s_std = ml86v7667_s_std,
	.querystd = ml86v7667_querystd,
	.g_input_status = ml86v7667_g_input_status,
	.try_mbus_fmt = ml86v7667_mbus_fmt,
	.g_mbus_fmt = ml86v7667_mbus_fmt,
	.s_mbus_fmt = ml86v7667_mbus_fmt,
	.g_mbus_config = ml86v7667_g_mbus_config,
};

static const struct v4l2_subdev_pad_ops ml86v7667_subdev_pad_ops = {
	.enum_mbus_code = ml86v7667_enum_mbus_code,
	.get_fmt = ml86v7667_fill_fmt,
	.set_fmt = ml86v7667_fill_fmt,
};

static struct v4l2_subdev_core_ops ml86v7667_subdev_core_ops = {

static int saa6752hs_init(struct v4l2_subdev *sd, u32 leading_null_bytes)	return 0;
}

static int saa6752hs_g_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *f)
static int saa6752hs_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *f = &format->format;
	struct saa6752hs_state *h = to_state(sd);

	if (format->pad)
		return -EINVAL;

	if (h->video_format == SAA6752HS_VF_UNKNOWN)
		h->video_format = SAA6752HS_VF_D1;
	f->width = v4l2_format_table[h->video_format].fmt.pix.width;

static const struct v4l2_subdev_video_ops saa6752hs_video_ops = {	.s_std = saa6752hs_s_std,
	.s_mbus_fmt = saa6752hs_s_mbus_fmt,
	.try_mbus_fmt = saa6752hs_try_mbus_fmt,
	.g_mbus_fmt = saa6752hs_g_mbus_fmt,
};

static const struct v4l2_subdev_pad_ops saa6752hs_pad_ops = {
	.get_fmt = saa6752hs_get_fmt,
};

static const struct v4l2_subdev_ops saa6752hs_ops = {
	.core = &saa6752hs_core_ops,
	.video = &saa6752hs_video_ops,
	.pad = &saa6752hs_pad_ops,
};

static int saa6752hs_probe(struct i2c_client *client,

static int imx074_s_fmt(struct v4l2_subdev *sd,	return 0;
}

static int imx074_g_fmt(struct v4l2_subdev *sd,
			struct v4l2_mbus_framefmt *mf)
static int imx074_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *mf = &format->format;
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct imx074 *priv = to_imx074(client);

	const struct imx074_datafmt *fmt = priv->fmt;

	if (format->pad)
		return -EINVAL;

	mf->code	= fmt->code;
	mf->colorspace	= fmt->colorspace;
	mf->width	= IMX074_WIDTH;

static int imx074_g_mbus_config(struct v4l2_subdev *sd,static struct v4l2_subdev_video_ops imx074_subdev_video_ops = {
	.s_stream	= imx074_s_stream,
	.s_mbus_fmt	= imx074_s_fmt,
	.g_mbus_fmt	= imx074_g_fmt,
	.try_mbus_fmt	= imx074_try_fmt,
	.g_crop		= imx074_g_crop,
	.cropcap	= imx074_cropcap,

static struct v4l2_subdev_core_ops imx074_subdev_core_ops = {
static const struct v4l2_subdev_pad_ops imx074_subdev_pad_ops = {
	.enum_mbus_code = imx074_enum_mbus_code,
	.get_fmt	= imx074_get_fmt,
};

static struct v4l2_subdev_ops imx074_subdev_ops = {

static int mt9m001_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)	return 0;
}

static int mt9m001_g_fmt(struct v4l2_subdev *sd,
			 struct v4l2_mbus_framefmt *mf)
static int mt9m001_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct mt9m001 *mt9m001 = to_mt9m001(client);
	struct v4l2_mbus_framefmt *mf = &format->format;

	if (format->pad)
		return -EINVAL;

	mf->width	= mt9m001->rect.width;
	mf->height	= mt9m001->rect.height;

static int mt9m001_s_mbus_config(struct v4l2_subdev *sd,static struct v4l2_subdev_video_ops mt9m001_subdev_video_ops = {
	.s_stream	= mt9m001_s_stream,
	.s_mbus_fmt	= mt9m001_s_fmt,
	.g_mbus_fmt	= mt9m001_g_fmt,
	.try_mbus_fmt	= mt9m001_try_fmt,
	.s_crop		= mt9m001_s_crop,
	.g_crop		= mt9m001_g_crop,

static struct v4l2_subdev_sensor_ops mt9m001_subdev_sensor_ops = {
static const struct v4l2_subdev_pad_ops mt9m001_subdev_pad_ops = {
	.enum_mbus_code = mt9m001_enum_mbus_code,
	.get_fmt	= mt9m001_get_fmt,
};

static struct v4l2_subdev_ops mt9m001_subdev_ops = {

static int mt9m111_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)	return 0;
}

static int mt9m111_g_fmt(struct v4l2_subdev *sd,
			 struct v4l2_mbus_framefmt *mf)
static int mt9m111_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *mf = &format->format;
	struct mt9m111 *mt9m111 = container_of(sd, struct mt9m111, subdev);

	if (format->pad)
		return -EINVAL;

	mf->width	= mt9m111->width;
	mf->height	= mt9m111->height;
	mf->code	= mt9m111->fmt->code;

static int mt9m111_g_mbus_config(struct v4l2_subdev *sd,
static struct v4l2_subdev_video_ops mt9m111_subdev_video_ops = {
	.s_mbus_fmt	= mt9m111_s_fmt,
	.g_mbus_fmt	= mt9m111_g_fmt,
	.try_mbus_fmt	= mt9m111_try_fmt,
	.s_crop		= mt9m111_s_crop,
	.g_crop		= mt9m111_g_crop,

static struct v4l2_subdev_video_ops mt9m111_subdev_video_ops = {
static const struct v4l2_subdev_pad_ops mt9m111_subdev_pad_ops = {
	.enum_mbus_code = mt9m111_enum_mbus_code,
	.get_fmt	= mt9m111_get_fmt,
};

static struct v4l2_subdev_ops mt9m111_subdev_ops = {

static int mt9t031_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)	return 0;
}

static int mt9t031_g_fmt(struct v4l2_subdev *sd,
			 struct v4l2_mbus_framefmt *mf)
static int mt9t031_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *mf = &format->format;
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct mt9t031 *mt9t031 = to_mt9t031(client);

	if (format->pad)
		return -EINVAL;

	mf->width	= mt9t031->rect.width / mt9t031->xskip;
	mf->height	= mt9t031->rect.height / mt9t031->yskip;
	mf->code	= MEDIA_BUS_FMT_SBGGR10_1X10;

static int mt9t031_s_mbus_config(struct v4l2_subdev *sd,static struct v4l2_subdev_video_ops mt9t031_subdev_video_ops = {
	.s_stream	= mt9t031_s_stream,
	.s_mbus_fmt	= mt9t031_s_fmt,
	.g_mbus_fmt	= mt9t031_g_fmt,
	.try_mbus_fmt	= mt9t031_try_fmt,
	.s_crop		= mt9t031_s_crop,
	.g_crop		= mt9t031_g_crop,

static struct v4l2_subdev_sensor_ops mt9t031_subdev_sensor_ops = {
static const struct v4l2_subdev_pad_ops mt9t031_subdev_pad_ops = {
	.enum_mbus_code = mt9t031_enum_mbus_code,
	.get_fmt	= mt9t031_get_fmt,
};

static struct v4l2_subdev_ops mt9t031_subdev_ops = {

static int mt9t112_s_crop(struct v4l2_subdev *sd, const struct v4l2_crop *a)	return mt9t112_set_params(priv, rect, priv->format->code);
}

static int mt9t112_g_fmt(struct v4l2_subdev *sd,
			 struct v4l2_mbus_framefmt *mf)
static int mt9t112_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *mf = &format->format;
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct mt9t112_priv *priv = to_mt9t112(client);

	if (format->pad)
		return -EINVAL;

	mf->width	= priv->frame.width;
	mf->height	= priv->frame.height;
	mf->colorspace	= priv->format->colorspace;

static int mt9t112_s_mbus_config(struct v4l2_subdev *sd,
static struct v4l2_subdev_video_ops mt9t112_subdev_video_ops = {
	.s_stream	= mt9t112_s_stream,
	.g_mbus_fmt	= mt9t112_g_fmt,
	.s_mbus_fmt	= mt9t112_s_fmt,
	.try_mbus_fmt	= mt9t112_try_fmt,
	.cropcap	= mt9t112_cropcap,

static struct v4l2_subdev_video_ops mt9t112_subdev_video_ops = {
static const struct v4l2_subdev_pad_ops mt9t112_subdev_pad_ops = {
	.enum_mbus_code = mt9t112_enum_mbus_code,
	.get_fmt	= mt9t112_get_fmt,
};

/************************************************************************

static int mt9v022_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)	return 0;
}

static int mt9v022_g_fmt(struct v4l2_subdev *sd,
			 struct v4l2_mbus_framefmt *mf)
static int mt9v022_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *mf = &format->format;
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct mt9v022 *mt9v022 = to_mt9v022(client);

	if (format->pad)
		return -EINVAL;

	mf->width	= mt9v022->rect.width;
	mf->height	= mt9v022->rect.height;
	mf->code	= mt9v022->fmt->code;

static int mt9v022_s_mbus_config(struct v4l2_subdev *sd,static struct v4l2_subdev_video_ops mt9v022_subdev_video_ops = {
	.s_stream	= mt9v022_s_stream,
	.s_mbus_fmt	= mt9v022_s_fmt,
	.g_mbus_fmt	= mt9v022_g_fmt,
	.try_mbus_fmt	= mt9v022_try_fmt,
	.s_crop		= mt9v022_s_crop,
	.g_crop		= mt9v022_g_crop,

static struct v4l2_subdev_sensor_ops mt9v022_subdev_sensor_ops = {
static const struct v4l2_subdev_pad_ops mt9v022_subdev_pad_ops = {
	.enum_mbus_code = mt9v022_enum_mbus_code,
	.get_fmt	= mt9v022_get_fmt,
};

static struct v4l2_subdev_ops mt9v022_subdev_ops = {

static int ov2640_set_params(struct i2c_client *client, u32 *width, u32 *height,	return ret;
}

static int ov2640_g_fmt(struct v4l2_subdev *sd,
			struct v4l2_mbus_framefmt *mf)
static int ov2640_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *mf = &format->format;
	struct i2c_client  *client = v4l2_get_subdevdata(sd);
	struct ov2640_priv *priv = to_ov2640(client);

	if (format->pad)
		return -EINVAL;

	if (!priv->win) {
		u32 width = SVGA_WIDTH, height = SVGA_HEIGHT;
		priv->win = ov2640_select_win(&width, &height);

static int ov2640_g_mbus_config(struct v4l2_subdev *sd,
static struct v4l2_subdev_video_ops ov2640_subdev_video_ops = {
	.s_stream	= ov2640_s_stream,
	.g_mbus_fmt	= ov2640_g_fmt,
	.s_mbus_fmt	= ov2640_s_fmt,
	.try_mbus_fmt	= ov2640_try_fmt,
	.cropcap	= ov2640_cropcap,

static struct v4l2_subdev_video_ops ov2640_subdev_video_ops = {
static const struct v4l2_subdev_pad_ops ov2640_subdev_pad_ops = {
	.enum_mbus_code = ov2640_enum_mbus_code,
	.get_fmt	= ov2640_get_fmt,
};

static struct v4l2_subdev_ops ov2640_subdev_ops = {

static int ov5642_s_fmt(struct v4l2_subdev *sd,	return 0;
}

static int ov5642_g_fmt(struct v4l2_subdev *sd,
			struct v4l2_mbus_framefmt *mf)
static int ov5642_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *mf = &format->format;
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct ov5642 *priv = to_ov5642(client);

	const struct ov5642_datafmt *fmt = priv->fmt;

	if (format->pad)
		return -EINVAL;

	mf->code	= fmt->code;
	mf->colorspace	= fmt->colorspace;
	mf->width	= priv->crop_rect.width;

static int ov5642_s_power(struct v4l2_subdev *sd, int on)
static struct v4l2_subdev_video_ops ov5642_subdev_video_ops = {
	.s_mbus_fmt	= ov5642_s_fmt,
	.g_mbus_fmt	= ov5642_g_fmt,
	.try_mbus_fmt	= ov5642_try_fmt,
	.s_crop		= ov5642_s_crop,
	.g_crop		= ov5642_g_crop,

static struct v4l2_subdev_video_ops ov5642_subdev_video_ops = {
static const struct v4l2_subdev_pad_ops ov5642_subdev_pad_ops = {
	.enum_mbus_code = ov5642_enum_mbus_code,
	.get_fmt	= ov5642_get_fmt,
};

static struct v4l2_subdev_core_ops ov5642_subdev_core_ops = {

static int ov6650_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)	return 0;
}

static int ov6650_g_fmt(struct v4l2_subdev *sd,
			 struct v4l2_mbus_framefmt *mf)
static int ov6650_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *mf = &format->format;
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct ov6650 *priv = to_ov6650(client);

	if (format->pad)
		return -EINVAL;

	mf->width	= priv->rect.width >> priv->half_scale;
	mf->height	= priv->rect.height >> priv->half_scale;
	mf->code	= priv->code;

static int ov6650_s_mbus_config(struct v4l2_subdev *sd,
static struct v4l2_subdev_video_ops ov6650_video_ops = {
	.s_stream	= ov6650_s_stream,
	.g_mbus_fmt	= ov6650_g_fmt,
	.s_mbus_fmt	= ov6650_s_fmt,
	.try_mbus_fmt	= ov6650_try_fmt,
	.cropcap	= ov6650_cropcap,

static struct v4l2_subdev_video_ops ov6650_video_ops = {
static const struct v4l2_subdev_pad_ops ov6650_pad_ops = {
	.enum_mbus_code = ov6650_enum_mbus_code,
	.get_fmt	= ov6650_get_fmt,
};

static struct v4l2_subdev_ops ov6650_subdev_ops = {

static int ov772x_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)	return 0;
}

static int ov772x_g_fmt(struct v4l2_subdev *sd,
			struct v4l2_mbus_framefmt *mf)
static int ov772x_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *mf = &format->format;
	struct ov772x_priv *priv = to_ov772x(sd);

	if (format->pad)
		return -EINVAL;

	mf->width	= priv->win->rect.width;
	mf->height	= priv->win->rect.height;
	mf->code	= priv->cfmt->code;

static int ov772x_g_mbus_config(struct v4l2_subdev *sd,
static struct v4l2_subdev_video_ops ov772x_subdev_video_ops = {
	.s_stream	= ov772x_s_stream,
	.g_mbus_fmt	= ov772x_g_fmt,
	.s_mbus_fmt	= ov772x_s_fmt,
	.try_mbus_fmt	= ov772x_try_fmt,
	.cropcap	= ov772x_cropcap,

static struct v4l2_subdev_video_ops ov772x_subdev_video_ops = {
static const struct v4l2_subdev_pad_ops ov772x_subdev_pad_ops = {
	.enum_mbus_code = ov772x_enum_mbus_code,
	.get_fmt	= ov772x_get_fmt,
};

static struct v4l2_subdev_ops ov772x_subdev_ops = {

static int rj54n1_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)	return 0;
}

static int rj54n1_g_fmt(struct v4l2_subdev *sd,
			struct v4l2_mbus_framefmt *mf)
static int rj54n1_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *mf = &format->format;
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct rj54n1 *rj54n1 = to_rj54n1(client);

	if (format->pad)
		return -EINVAL;

	mf->code	= rj54n1->fmt->code;
	mf->colorspace	= rj54n1->fmt->colorspace;
	mf->field	= V4L2_FIELD_NONE;

static int rj54n1_s_mbus_config(struct v4l2_subdev *sd,static struct v4l2_subdev_video_ops rj54n1_subdev_video_ops = {
	.s_stream	= rj54n1_s_stream,
	.s_mbus_fmt	= rj54n1_s_fmt,
	.g_mbus_fmt	= rj54n1_g_fmt,
	.try_mbus_fmt	= rj54n1_try_fmt,
	.g_crop		= rj54n1_g_crop,
	.s_crop		= rj54n1_s_crop,

static struct v4l2_subdev_video_ops rj54n1_subdev_video_ops = {
static const struct v4l2_subdev_pad_ops rj54n1_subdev_pad_ops = {
	.enum_mbus_code = rj54n1_enum_mbus_code,
	.get_fmt	= rj54n1_get_fmt,
};

static struct v4l2_subdev_ops rj54n1_subdev_ops = {

static int tw9910_cropcap(struct v4l2_subdev *sd, struct v4l2_cropcap *a)	return 0;
}

static int tw9910_g_fmt(struct v4l2_subdev *sd,
			struct v4l2_mbus_framefmt *mf)
static int tw9910_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *mf = &format->format;
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct tw9910_priv *priv = to_tw9910(client);

	if (format->pad)
		return -EINVAL;

	if (!priv->scale) {
		priv->scale = tw9910_select_norm(priv->norm, 640, 480);
		if (!priv->scale)

static struct v4l2_subdev_video_ops tw9910_subdev_video_ops = {	.s_std		= tw9910_s_std,
	.g_std		= tw9910_g_std,
	.s_stream	= tw9910_s_stream,
	.g_mbus_fmt	= tw9910_g_fmt,
	.s_mbus_fmt	= tw9910_s_fmt,
	.try_mbus_fmt	= tw9910_try_fmt,
	.cropcap	= tw9910_cropcap,

static struct v4l2_subdev_video_ops tw9910_subdev_video_ops = {
static const struct v4l2_subdev_pad_ops tw9910_subdev_pad_ops = {
	.enum_mbus_code = tw9910_enum_mbus_code,
	.get_fmt	= tw9910_get_fmt,
};

static struct v4l2_subdev_ops tw9910_subdev_ops = {

static int sr030pc30_enum_mbus_code(struct v4l2_subdev *sd,	return 0;
}

static int sr030pc30_g_fmt(struct v4l2_subdev *sd,
			   struct v4l2_mbus_framefmt *mf)
static int sr030pc30_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *mf;
	struct sr030pc30_info *info = to_sr030pc30(sd);
	int ret;

	if (!mf)
	if (!format || format->pad)
		return -EINVAL;

	mf = &format->format;

	if (!info->curr_win || !info->curr_fmt) {
		ret = sr030pc30_set_params(sd);
		if (ret)

static const struct v4l2_subdev_core_ops sr030pc30_core_ops = {};

static const struct v4l2_subdev_video_ops sr030pc30_video_ops = {
	.g_mbus_fmt	= sr030pc30_g_fmt,
	.s_mbus_fmt	= sr030pc30_s_fmt,
	.try_mbus_fmt	= sr030pc30_try_fmt,
};

static const struct v4l2_subdev_pad_ops sr030pc30_pad_ops = {
	.enum_mbus_code = sr030pc30_enum_mbus_code,
	.get_fmt	= sr030pc30_get_fmt,
};

static const struct v4l2_subdev_ops sr030pc30_ops = {

static int tvp514x_s_ctrl(struct v4l2_ctrl *ctrl)	return err;
}

/**
 * tvp514x_mbus_fmt() - V4L2 decoder interface handler for try/s/g_mbus_fmt
 * @sd: pointer to standard V4L2 sub-device structure
 * @f: pointer to the mediabus format structure
 *
 * Negotiates the image capture size and mediabus format.
 */
static int
tvp514x_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *f)
{
	struct tvp514x_decoder *decoder = to_decoder(sd);
	enum tvp514x_std current_std;

	if (f == NULL)
		return -EINVAL;

	/* Calculate height and width based on current standard */
	current_std = decoder->current_std;

	f->code = MEDIA_BUS_FMT_YUYV8_2X8;
	f->width = decoder->std_list[current_std].width;
	f->height = decoder->std_list[current_std].height;
	f->field = V4L2_FIELD_INTERLACED;
	f->colorspace = V4L2_COLORSPACE_SMPTE170M;
	v4l2_dbg(1, debug, sd, "MBUS_FMT: Width - %d, Height - %d\n",
			f->width, f->height);
	return 0;
}

/**
 * tvp514x_g_parm() - V4L2 decoder interface handler for g_parm
 * @sd: pointer to standard V4L2 sub-device structure

static int tvp514x_get_pad_format(struct v4l2_subdev *sd,	struct tvp514x_decoder *decoder = to_decoder(sd);
	__u32 which = format->which;

	if (format->pad)
		return -EINVAL;

	if (which == V4L2_SUBDEV_FORMAT_ACTIVE) {
		format->format = decoder->format;
		return 0;

static const struct v4l2_subdev_video_ops tvp514x_video_ops = {	.s_std = tvp514x_s_std,
	.s_routing = tvp514x_s_routing,
	.querystd = tvp514x_querystd,
	.g_mbus_fmt = tvp514x_mbus_fmt,
	.try_mbus_fmt = tvp514x_mbus_fmt,
	.s_mbus_fmt = tvp514x_mbus_fmt,
	.g_parm = tvp514x_g_parm,
	.s_parm = tvp514x_s_parm,
	.s_stream = tvp514x_s_stream,

static int tvp5150_enum_mbus_code(struct v4l2_subdev *sd,	return 0;
}

static int tvp5150_mbus_fmt(struct v4l2_subdev *sd,
			    struct v4l2_mbus_framefmt *f)
static int tvp5150_fill_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *f;
	struct tvp5150 *decoder = to_tvp5150(sd);

	if (f == NULL)
	if (!format || format->pad)
		return -EINVAL;

	f = &format->format;

	tvp5150_reset(sd, 0);

	f->width = decoder->rect.width;

static const struct v4l2_subdev_tuner_ops tvp5150_tuner_ops = {static const struct v4l2_subdev_video_ops tvp5150_video_ops = {
	.s_std = tvp5150_s_std,
	.s_routing = tvp5150_s_routing,
	.s_mbus_fmt = tvp5150_mbus_fmt,
	.try_mbus_fmt = tvp5150_mbus_fmt,
	.g_mbus_fmt = tvp5150_mbus_fmt,
	.s_crop = tvp5150_s_crop,
	.g_crop = tvp5150_g_crop,
	.cropcap = tvp5150_cropcap,

static const struct v4l2_subdev_vbi_ops tvp5150_vbi_ops = {
static const struct v4l2_subdev_pad_ops tvp5150_pad_ops = {
	.enum_mbus_code = tvp5150_enum_mbus_code,
	.set_fmt = tvp5150_fill_fmt,
	.get_fmt = tvp5150_fill_fmt,
};

static const struct v4l2_subdev_ops tvp5150_ops = {

static int tvp7002_s_ctrl(struct v4l2_ctrl *ctrl)	return -EINVAL;
}

/*
 * tvp7002_mbus_fmt() - V4L2 decoder interface handler for try/s/g_mbus_fmt
 * @sd: pointer to standard V4L2 sub-device structure
 * @f: pointer to mediabus format structure
 *
 * Negotiate the image capture size and mediabus format.
 * There is only one possible format, so this single function works for
 * get, set and try.
 */
static int tvp7002_mbus_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *f)
{
	struct tvp7002 *device = to_tvp7002(sd);
	const struct v4l2_bt_timings *bt = &device->current_timings->timings.bt;

	f->width = bt->width;
	f->height = bt->height;
	f->code = MEDIA_BUS_FMT_YUYV10_1X20;
	f->field = device->current_timings->scanmode;
	f->colorspace = device->current_timings->color_space;

	v4l2_dbg(1, debug, sd, "MBUS_FMT: Width - %d, Height - %d",
			f->width, f->height);
	return 0;
}

/*
 * tvp7002_query_dv() - query DV timings
 * @sd: pointer to standard V4L2 sub-device structure

static const struct v4l2_subdev_video_ops tvp7002_video_ops = {	.s_dv_timings = tvp7002_s_dv_timings,
	.query_dv_timings = tvp7002_query_dv_timings,
	.s_stream = tvp7002_s_stream,
	.g_mbus_fmt = tvp7002_mbus_fmt,
	.try_mbus_fmt = tvp7002_mbus_fmt,
	.s_mbus_fmt = tvp7002_mbus_fmt,
};

/* media pad related operation handlers */

static int vs6624_s_mbus_fmt(struct v4l2_subdev *sd,	return 0;
}

static int vs6624_g_mbus_fmt(struct v4l2_subdev *sd,
				struct v4l2_mbus_framefmt *fmt)
static int vs6624_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct vs6624 *sensor = to_vs6624(sd);

	*fmt = sensor->fmt;
	if (format->pad)
		return -EINVAL;

	format->format = sensor->fmt;
	return 0;
}


static const struct v4l2_subdev_core_ops vs6624_core_ops = {static const struct v4l2_subdev_video_ops vs6624_video_ops = {
	.try_mbus_fmt = vs6624_try_mbus_fmt,
	.s_mbus_fmt = vs6624_s_mbus_fmt,
	.g_mbus_fmt = vs6624_g_mbus_fmt,
	.s_parm = vs6624_s_parm,
	.g_parm = vs6624_g_parm,
	.s_stream = vs6624_s_stream,

static const struct v4l2_subdev_video_ops vs6624_video_ops = {
static const struct v4l2_subdev_pad_ops vs6624_pad_ops = {
	.enum_mbus_code = vs6624_enum_mbus_code,
	.get_fmt = vs6624_get_fmt,
};

static const struct v4l2_subdev_ops vs6624_ops = {

static int empress_g_fmt_vid_cap(struct file *file, void *priv,				struct v4l2_format *f)
{
	struct saa7134_dev *dev = video_drvdata(file);
	struct v4l2_mbus_framefmt mbus_fmt;
	struct v4l2_subdev_format fmt = {
		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
	};
	struct v4l2_mbus_framefmt *mbus_fmt = &fmt.format;

	saa_call_all(dev, video, g_mbus_fmt, &mbus_fmt);
	saa_call_all(dev, pad, get_fmt, NULL, &fmt);

	v4l2_fill_pix_format(&f->fmt.pix, &mbus_fmt);
	v4l2_fill_pix_format(&f->fmt.pix, mbus_fmt);
	f->fmt.pix.pixelformat  = V4L2_PIX_FMT_MPEG;
	f->fmt.pix.sizeimage    = TS_PACKET_SIZE * dev->ts.nr_packets;
	f->fmt.pix.bytesperline = 0;

static int vpfe_config_ccdc_image_format(struct vpfe_device *vpfe) * For a given standard, this functions sets up the default
 * pix format & crop values in the vpfe device and ccdc.  It first
 * starts with defaults based values from the standard table.
 * It then checks if sub device support g_mbus_fmt and then override the
 * It then checks if sub device supports get_fmt and then override the
 * values based on that.Sets crop values to match with scan resolution
 * starting at 0,0. It calls vpfe_config_ccdc_image_format() set the
 * values in ccdc

static int __vpfe_get_format(struct vpfe_device *vpfe,	} else {
		ret = v4l2_device_call_until_err(&vpfe->v4l2_dev,
						 sdinfo->grp_id,
						 video, g_mbus_fmt,
						 &mbus_fmt);
						 pad, get_fmt,
						 NULL, &fmt);
		if (ret && ret != -ENOIOCTLCMD && ret != -ENODEV)
			return ret;
		v4l2_fill_pix_format(&format->fmt.pix, &mbus_fmt);

static int vpfe_config_ccdc_image_format(struct vpfe_device *vpfe_dev) * For a given standard, this functions sets up the default
 * pix format & crop values in the vpfe device and ccdc.  It first
 * starts with defaults based values from the standard table.
 * It then checks if sub device support g_mbus_fmt and then override the
 * It then checks if sub device supports get_fmt and then override the
 * values based on that.Sets crop values to match with scan resolution
 * starting at 0,0. It calls vpfe_config_ccdc_image_format() set the
 * values in ccdc

static int vpfe_config_image_format(struct vpfe_device *vpfe_dev,				    v4l2_std_id std_id)
{
	struct vpfe_subdev_info *sdinfo = vpfe_dev->current_subdev;
	struct v4l2_mbus_framefmt mbus_fmt;
	struct v4l2_subdev_format fmt = {
		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
	};
	struct v4l2_mbus_framefmt *mbus_fmt = &fmt.format;
	struct v4l2_pix_format *pix = &vpfe_dev->fmt.fmt.pix;
	int i, ret = 0;


static int vpfe_config_image_format(struct vpfe_device *vpfe_dev,		pix->field = V4L2_FIELD_INTERLACED;
		/* assume V4L2_PIX_FMT_UYVY as default */
		pix->pixelformat = V4L2_PIX_FMT_UYVY;
		v4l2_fill_mbus_format(&mbus_fmt, pix,
		v4l2_fill_mbus_format(mbus_fmt, pix,
				MEDIA_BUS_FMT_YUYV10_2X10);
	} else {
		pix->field = V4L2_FIELD_NONE;
		/* assume V4L2_PIX_FMT_SBGGR8 */
		pix->pixelformat = V4L2_PIX_FMT_SBGGR8;
		v4l2_fill_mbus_format(&mbus_fmt, pix,
		v4l2_fill_mbus_format(mbus_fmt, pix,
				MEDIA_BUS_FMT_SBGGR8_1X8);
	}

	/* if sub device supports g_mbus_fmt, override the defaults */
	/* if sub device supports get_fmt, override the defaults */
	ret = v4l2_device_call_until_err(&vpfe_dev->v4l2_dev,
			sdinfo->grp_id, video, g_mbus_fmt, &mbus_fmt);
			sdinfo->grp_id, pad, get_fmt, NULL, &fmt);

	if (ret && ret != -ENOIOCTLCMD) {
		v4l2_err(&vpfe_dev->v4l2_dev,
			"error in getting g_mbus_fmt from sub device\n");
			"error in getting get_fmt from sub device\n");
		return ret;
	}
	v4l2_fill_pix_format(pix, &mbus_fmt);
	v4l2_fill_pix_format(pix, mbus_fmt);
	pix->bytesperline = pix->width * 2;
	pix->sizeimage = pix->bytesperline * pix->height;


static int hdmi_g_dv_timings(struct v4l2_subdev *sd,	return 0;
}

static int hdmi_g_mbus_fmt(struct v4l2_subdev *sd,
	  struct v4l2_mbus_framefmt *fmt)
static int hdmi_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *fmt = &format->format;
	struct hdmi_device *hdev = sd_to_hdmi_dev(sd);
	const struct hdmi_timings *t = hdev->cur_conf;

	dev_dbg(hdev->dev, "%s\n", __func__);
	if (!hdev->cur_conf)
		return -EINVAL;
	if (format->pad)
		return -EINVAL;

	memset(fmt, 0, sizeof(*fmt));
	fmt->width = t->hact.end - t->hact.beg;
	fmt->height = t->vact[0].end - t->vact[0].beg;

static const struct v4l2_subdev_core_ops hdmi_sd_core_ops = {static const struct v4l2_subdev_video_ops hdmi_sd_video_ops = {
	.s_dv_timings = hdmi_s_dv_timings,
	.g_dv_timings = hdmi_g_dv_timings,
	.g_mbus_fmt = hdmi_g_mbus_fmt,
	.s_stream = hdmi_s_stream,
};

static const struct v4l2_subdev_pad_ops hdmi_sd_pad_ops = {
	.enum_dv_timings = hdmi_enum_dv_timings,
	.dv_timings_cap = hdmi_dv_timings_cap,
	.get_fmt = hdmi_get_fmt,
};

static const struct v4l2_subdev_ops hdmi_sd_ops = {
	.core = &hdmi_sd_core_ops,
	.video = &hdmi_sd_video_ops,
	.pad = &hdmi_sd_pad_ops,
};

static int hdmi_runtime_suspend(struct device *dev)

void mxr_get_mbus_fmt(struct mxr_device *mdev,	struct v4l2_mbus_framefmt *mbus_fmt)
{
	struct v4l2_subdev *sd;
	struct v4l2_subdev_format fmt = {
		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
	};
	int ret;

	mutex_lock(&mdev->mutex);
	sd = to_outsd(mdev);
	ret = v4l2_subdev_call(sd, video, g_mbus_fmt, mbus_fmt);
	ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);
	*mbus_fmt = fmt.format;
	WARN(ret, "failed to get mbus_fmt for output %s\n", sd->name);
	mutex_unlock(&mdev->mutex);
}

void mxr_streamer_get(struct mxr_device *mdev)	mxr_dbg(mdev, "%s(%d)\n", __func__, mdev->n_streamer);
	if (mdev->n_streamer == 1) {
		struct v4l2_subdev *sd = to_outsd(mdev);
		struct v4l2_mbus_framefmt mbus_fmt;
		struct v4l2_subdev_format fmt = {
			.which = V4L2_SUBDEV_FORMAT_ACTIVE,
		};
		struct v4l2_mbus_framefmt *mbus_fmt = &fmt.format;
		struct mxr_resources *res = &mdev->res;
		int ret;


void mxr_streamer_get(struct mxr_device *mdev)			clk_set_parent(res->sclk_mixer, res->sclk_hdmi);
		mxr_reg_s_output(mdev, to_output(mdev)->cookie);

		ret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mbus_fmt);
		ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);
		WARN(ret, "failed to get mbus_fmt for output %s\n", sd->name);
		ret = v4l2_subdev_call(sd, video, s_stream, 1);
		WARN(ret, "starting stream failed for output %s\n", sd->name);

		mxr_reg_set_mbus_fmt(mdev, &mbus_fmt);
		mxr_reg_set_mbus_fmt(mdev, mbus_fmt);
		mxr_reg_streamon(mdev);
		ret = mxr_reg_wait4vsync(mdev);
		WARN(ret, "failed to get vsync (%d) from output\n", ret);

static int sdo_g_std_output(struct v4l2_subdev *sd, v4l2_std_id *std)	return 0;
}

static int sdo_g_mbus_fmt(struct v4l2_subdev *sd,
	struct v4l2_mbus_framefmt *fmt)
static int sdo_get_fmt(struct v4l2_subdev *sd,
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *fmt = &format->format;
	struct sdo_device *sdev = sd_to_sdev(sd);

	if (!sdev->fmt)
		return -ENXIO;
	if (format->pad)
		return -EINVAL;
	/* all modes are 720 pixels wide */
	fmt->width = 720;
	fmt->height = sdev->fmt->height;

static const struct v4l2_subdev_video_ops sdo_sd_video_ops = {	.s_std_output = sdo_s_std_output,
	.g_std_output = sdo_g_std_output,
	.g_tvnorms_output = sdo_g_tvnorms_output,
	.g_mbus_fmt = sdo_g_mbus_fmt,
	.s_stream = sdo_s_stream,
};

static const struct v4l2_subdev_pad_ops sdo_sd_pad_ops = {
	.get_fmt = sdo_get_fmt,
};

static const struct v4l2_subdev_ops sdo_sd_ops = {
	.core = &sdo_sd_core_ops,
	.video = &sdo_sd_video_ops,
	.pad = &sdo_sd_pad_ops,
};

static int sdo_runtime_suspend(struct device *dev)

static int mx2_camera_set_crop(struct soc_camera_device *icd,	struct v4l2_crop a_writable = *a;
	struct v4l2_rect *rect = &a_writable.c;
	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
	struct v4l2_mbus_framefmt mf;
	struct v4l2_subdev_format fmt = {
		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
	};
	struct v4l2_mbus_framefmt *mf = &fmt.format;
	int ret;

	soc_camera_limit_side(&rect->left, &rect->width, 0, 2, 4096);

static int mx2_camera_set_crop(struct soc_camera_device *icd,		return ret;

	/* The capture device might have changed its output  */
	ret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mf);
	ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);
	if (ret < 0)
		return ret;

	dev_dbg(icd->parent, "Sensor cropped %dx%d\n",
		mf.width, mf.height);
		mf->width, mf->height);

	icd->user_width		= mf.width;
	icd->user_height	= mf.height;
	icd->user_width		= mf->width;
	icd->user_height	= mf->height;

	return ret;
}

static int mx3_camera_set_crop(struct soc_camera_device *icd,	struct soc_camera_host *ici = to_soc_camera_host(icd->parent);
	struct mx3_camera_dev *mx3_cam = ici->priv;
	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
	struct v4l2_mbus_framefmt mf;
	struct v4l2_subdev_format fmt = {
		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
	};
	struct v4l2_mbus_framefmt *mf = &fmt.format;
	int ret;

	soc_camera_limit_side(&rect->left, &rect->width, 0, 2, 4096);

static int mx3_camera_set_crop(struct soc_camera_device *icd,		return ret;

	/* The capture device might have changed its output sizes */
	ret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mf);
	ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);
	if (ret < 0)
		return ret;

	if (mf.code != icd->current_fmt->code)
	if (mf->code != icd->current_fmt->code)
		return -EINVAL;

	if (mf.width & 7) {
	if (mf->width & 7) {
		/* Ouch! We can only handle 8-byte aligned width... */
		stride_align(&mf.width);
		ret = v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);
		stride_align(&mf->width);
		ret = v4l2_subdev_call(sd, video, s_mbus_fmt, mf);
		if (ret < 0)
			return ret;
	}

	if (mf.width != icd->user_width || mf.height != icd->user_height)
		configure_geometry(mx3_cam, mf.width, mf.height,
	if (mf->width != icd->user_width || mf->height != icd->user_height)
		configure_geometry(mx3_cam, mf->width, mf->height,
				   icd->current_fmt->host_fmt);

	dev_dbg(icd->parent, "Sensor cropped %dx%d\n",
		mf.width, mf.height);
		mf->width, mf->height);

	icd->user_width		= mf.width;
	icd->user_height	= mf.height;
	icd->user_width		= mf->width;
	icd->user_height	= mf->height;

	return ret;
}

static int omap1_cam_set_crop(struct soc_camera_device *icd,	struct device *dev = icd->parent;
	struct soc_camera_host *ici = to_soc_camera_host(dev);
	struct omap1_cam_dev *pcdev = ici->priv;
	struct v4l2_mbus_framefmt mf;
	struct v4l2_subdev_format fmt = {
		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
	};
	struct v4l2_mbus_framefmt *mf = &fmt.format;
	int ret;

	ret = subdev_call_with_sense(pcdev, dev, icd, sd, s_crop, crop);

static int omap1_cam_set_crop(struct soc_camera_device *icd,		return ret;
	}

	ret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mf);
	ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);
	if (ret < 0) {
		dev_warn(dev, "%s: failed to fetch current format\n", __func__);
		return ret;
	}

	ret = dma_align(&mf.width, &mf.height, xlate->host_fmt, pcdev->vb_mode,
	ret = dma_align(&mf->width, &mf->height, xlate->host_fmt, pcdev->vb_mode,
			false);
	if (ret < 0) {
		dev_err(dev, "%s: failed to align %ux%u %s with DMA\n",
				__func__, mf.width, mf.height,
				__func__, mf->width, mf->height,
				xlate->host_fmt->name);
		return ret;
	}

	if (!ret) {
		/* sensor returned geometry not DMA aligned, trying to fix */
		ret = set_mbus_format(pcdev, dev, icd, sd, &mf, xlate);
		ret = set_mbus_format(pcdev, dev, icd, sd, mf, xlate);
		if (ret < 0) {
			dev_err(dev, "%s: failed to set format\n", __func__);
			return ret;
		}
	}

	icd->user_width	 = mf.width;
	icd->user_height = mf.height;
	icd->user_width	 = mf->width;
	icd->user_height = mf->height;

	return 0;
}

static int pxa_camera_set_crop(struct soc_camera_device *icd,		.master_clock = pcdev->mclk,
		.pixel_clock_max = pcdev->ciclk / 4,
	};
	struct v4l2_mbus_framefmt mf;
	struct v4l2_subdev_format fmt = {
		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
	};
	struct v4l2_mbus_framefmt *mf = &fmt.format;
	struct pxa_cam *cam = icd->host_priv;
	u32 fourcc = icd->current_fmt->host_fmt->fourcc;
	int ret;

static int pxa_camera_set_crop(struct soc_camera_device *icd,		return ret;
	}

	ret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mf);
	ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);
	if (ret < 0)
		return ret;

	if (pxa_camera_check_frame(mf.width, mf.height)) {
	if (pxa_camera_check_frame(mf->width, mf->height)) {
		/*
		 * Camera cropping produced a frame beyond our capabilities.
		 * FIXME: just extract a subframe, that we can process.
		 */
		v4l_bound_align_image(&mf.width, 48, 2048, 1,
			&mf.height, 32, 2048, 0,
		v4l_bound_align_image(&mf->width, 48, 2048, 1,
			&mf->height, 32, 2048, 0,
			fourcc == V4L2_PIX_FMT_YUV422P ? 4 : 0);
		ret = v4l2_subdev_call(sd, video, s_mbus_fmt, &mf);
		ret = v4l2_subdev_call(sd, video, s_mbus_fmt, mf);
		if (ret < 0)
			return ret;

		if (pxa_camera_check_frame(mf.width, mf.height)) {
		if (pxa_camera_check_frame(mf->width, mf->height)) {
			dev_warn(icd->parent,
				 "Inconsistent state. Use S_FMT to repair\n");
			return -EINVAL;

static int pxa_camera_set_crop(struct soc_camera_device *icd,		recalculate_fifo_timeout(pcdev, sense.pixel_clock);
	}

	icd->user_width		= mf.width;
	icd->user_height	= mf.height;
	icd->user_width		= mf->width;
	icd->user_height	= mf->height;

	pxa_camera_setup_cicr(icd, cam->flags, fourcc);


static int rcar_vin_get_formats(struct soc_camera_device *icd, unsigned int idx,		return 0;

	if (!icd->host_priv) {
		struct v4l2_mbus_framefmt mf;
		struct v4l2_subdev_format fmt = {
			.which = V4L2_SUBDEV_FORMAT_ACTIVE,
		};
		struct v4l2_mbus_framefmt *mf = &fmt.format;
		struct v4l2_rect rect;
		struct device *dev = icd->parent;
		int shift;

		ret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mf);
		ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);
		if (ret < 0)
			return ret;


static int rcar_vin_get_formats(struct soc_camera_device *icd, unsigned int idx,			/* Sensor driver doesn't support cropping */
			rect.left = 0;
			rect.top = 0;
			rect.width = mf.width;
			rect.height = mf.height;
			rect.width = mf->width;
			rect.height = mf->height;
		} else if (ret < 0) {
			return ret;
		}

static int rcar_vin_get_formats(struct soc_camera_device *icd, unsigned int idx,		 * 1280x960, 640x480, 320x240
		 */
		for (shift = 0; shift < 3; shift++) {
			if (mf.width <= VIN_MAX_WIDTH &&
			    mf.height <= VIN_MAX_HEIGHT)
			if (mf->width <= VIN_MAX_WIDTH &&
			    mf->height <= VIN_MAX_HEIGHT)
				break;

			mf.width = 1280 >> shift;
			mf.height = 960 >> shift;
			mf->width = 1280 >> shift;
			mf->height = 960 >> shift;
			ret = v4l2_device_call_until_err(sd->v4l2_dev,
							 soc_camera_grp_id(icd),
							 video, s_mbus_fmt,
							 &mf);
							 mf);
			if (ret < 0)
				return ret;
		}

static int rcar_vin_get_formats(struct soc_camera_device *icd, unsigned int idx,		if (shift == 3) {
			dev_err(dev,
				"Failed to configure the client below %ux%u\n",
				mf.width, mf.height);
				mf->width, mf->height);
			return -EIO;
		}

		dev_dbg(dev, "camera fmt %ux%u\n", mf.width, mf.height);
		dev_dbg(dev, "camera fmt %ux%u\n", mf->width, mf->height);

		cam = kzalloc(sizeof(*cam), GFP_KERNEL);
		if (!cam)

static int rcar_vin_get_formats(struct soc_camera_device *icd, unsigned int idx,		 */
		cam->rect = rect;
		cam->subrect = rect;
		cam->width = mf.width;
		cam->height = mf.height;
		cam->out_width	= mf.width;
		cam->out_height	= mf.height;
		cam->width = mf->width;
		cam->height = mf->height;
		cam->out_width	= mf->width;
		cam->out_height	= mf->height;

		icd->host_priv = cam;
	} else {

static int rcar_vin_set_crop(struct soc_camera_device *icd,	struct v4l2_rect *cam_rect = &cam_crop.c;
	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
	struct device *dev = icd->parent;
	struct v4l2_mbus_framefmt mf;
	struct v4l2_subdev_format fmt = {
		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
	};
	struct v4l2_mbus_framefmt *mf = &fmt.format;
	u32 vnmc;
	int ret, i;


static int rcar_vin_set_crop(struct soc_camera_device *icd,	/* On success cam_crop contains current camera crop */

	/* Retrieve camera output window */
	ret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mf);
	ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);
	if (ret < 0)
		return ret;

	if (mf.width > VIN_MAX_WIDTH || mf.height > VIN_MAX_HEIGHT)
	if (mf->width > VIN_MAX_WIDTH || mf->height > VIN_MAX_HEIGHT)
		return -EINVAL;

	/* Cache camera output window */
	cam->width = mf.width;
	cam->height = mf.height;
	cam->width = mf->width;
	cam->height = mf->height;

	icd->user_width  = cam->width;
	icd->user_height = cam->height;

static int sh_mobile_ceu_get_formats(struct soc_camera_device *icd, unsigned int	}

	if (!icd->host_priv) {
		struct v4l2_mbus_framefmt mf;
		struct v4l2_subdev_format fmt = {
			.which = V4L2_SUBDEV_FORMAT_ACTIVE,
		};
		struct v4l2_mbus_framefmt *mf = &fmt.format;
		struct v4l2_rect rect;
		int shift = 0;


static int sh_mobile_ceu_get_formats(struct soc_camera_device *icd, unsigned int			return ret;

		/* First time */
		ret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mf);
		ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);
		if (ret < 0)
			return ret;


static int sh_mobile_ceu_get_formats(struct soc_camera_device *icd, unsigned int		 * sizes, just try VGA multiples. If needed, this can be
		 * adjusted in the future.
		 */
		while ((mf.width > pcdev->max_width ||
			mf.height > pcdev->max_height) && shift < 4) {
		while ((mf->width > pcdev->max_width ||
			mf->height > pcdev->max_height) && shift < 4) {
			/* Try 2560x1920, 1280x960, 640x480, 320x240 */
			mf.width	= 2560 >> shift;
			mf.height	= 1920 >> shift;
			mf->width	= 2560 >> shift;
			mf->height	= 1920 >> shift;
			ret = v4l2_device_call_until_err(sd->v4l2_dev,
					soc_camera_grp_id(icd), video,
					s_mbus_fmt, &mf);
					s_mbus_fmt, mf);
			if (ret < 0)
				return ret;
			shift++;

static int sh_mobile_ceu_get_formats(struct soc_camera_device *icd, unsigned int
		if (shift == 4) {
			dev_err(dev, "Failed to configure the client below %ux%x\n",
				mf.width, mf.height);
				mf->width, mf->height);
			return -EIO;
		}

		dev_geo(dev, "camera fmt %ux%u\n", mf.width, mf.height);
		dev_geo(dev, "camera fmt %ux%u\n", mf->width, mf->height);

		cam = kzalloc(sizeof(*cam), GFP_KERNEL);
		if (!cam)

static int sh_mobile_ceu_get_formats(struct soc_camera_device *icd, unsigned int		cam->rect	= rect;
		cam->subrect	= rect;

		cam->width	= mf.width;
		cam->height	= mf.height;
		cam->width	= mf->width;
		cam->height	= mf->height;

		icd->host_priv = cam;
	} else {

static int sh_mobile_ceu_set_crop(struct soc_camera_device *icd,	struct sh_mobile_ceu_cam *cam = icd->host_priv;
	struct v4l2_rect *cam_rect = &cam_crop.c;
	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
	struct v4l2_mbus_framefmt mf;
	struct v4l2_subdev_format fmt = {
		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
	};
	struct v4l2_mbus_framefmt *mf = &fmt.format;
	unsigned int scale_cam_h, scale_cam_v, scale_ceu_h, scale_ceu_v,
		out_width, out_height;
	int interm_width, interm_height;

static int sh_mobile_ceu_set_crop(struct soc_camera_device *icd,	/* On success cam_crop contains current camera crop */

	/* 3. Retrieve camera output window */
	ret = v4l2_subdev_call(sd, video, g_mbus_fmt, &mf);
	ret = v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt);
	if (ret < 0)
		return ret;

	if (mf.width > pcdev->max_width || mf.height > pcdev->max_height)
	if (mf->width > pcdev->max_width || mf->height > pcdev->max_height)
		return -EINVAL;

	/* 4. Calculate camera scales */
	scale_cam_h	= calc_generic_scale(cam_rect->width, mf.width);
	scale_cam_v	= calc_generic_scale(cam_rect->height, mf.height);
	scale_cam_h	= calc_generic_scale(cam_rect->width, mf->width);
	scale_cam_v	= calc_generic_scale(cam_rect->height, mf->height);

	/* Calculate intermediate window */
	interm_width	= scale_down(rect->width, scale_cam_h);

static int sh_mobile_ceu_set_crop(struct soc_camera_device *icd,
		new_scale_h = calc_generic_scale(rect->width, icd->user_width);

		mf.width = scale_down(cam_rect->width, new_scale_h);
		mf->width = scale_down(cam_rect->width, new_scale_h);
	}

	if (interm_height < icd->user_height) {

static int sh_mobile_ceu_set_crop(struct soc_camera_device *icd,
		new_scale_v = calc_generic_scale(rect->height, icd->user_height);

		mf.height = scale_down(cam_rect->height, new_scale_v);
		mf->height = scale_down(cam_rect->height, new_scale_v);
	}

	if (interm_width < icd->user_width || interm_height < icd->user_height) {
		ret = v4l2_device_call_until_err(sd->v4l2_dev,
					soc_camera_grp_id(icd), video,
					s_mbus_fmt, &mf);
					s_mbus_fmt, mf);
		if (ret < 0)
			return ret;

		dev_geo(dev, "New camera output %ux%u\n", mf.width, mf.height);
		scale_cam_h	= calc_generic_scale(cam_rect->width, mf.width);
		scale_cam_v	= calc_generic_scale(cam_rect->height, mf.height);
		dev_geo(dev, "New camera output %ux%u\n", mf->width, mf->height);
		scale_cam_h	= calc_generic_scale(cam_rect->width, mf->width);
		scale_cam_v	= calc_generic_scale(cam_rect->height, mf->height);
		interm_width	= scale_down(rect->width, scale_cam_h);
		interm_height	= scale_down(rect->height, scale_cam_v);
	}

	/* Cache camera output window */
	cam->width	= mf.width;
	cam->height	= mf.height;
	cam->width	= mf->width;
	cam->height	= mf->height;

	if (pcdev->image_mode) {
		out_width	= min(interm_width, icd->user_width);

static struct soc_camera_device *soc_camera_add_pdev(struct soc_camera_async_clistatic int soc_camera_probe_finish(struct soc_camera_device *icd)
{
	struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
	struct v4l2_mbus_framefmt mf;
	struct v4l2_subdev_format fmt = {
		.which = V4L2_SUBDEV_FORMAT_ACTIVE,
	};
	struct v4l2_mbus_framefmt *mf = &fmt.format;
	int ret;

	sd->grp_id = soc_camera_grp_id(icd);

static int soc_camera_probe_finish(struct soc_camera_device *icd)		goto evidstart;

	/* Try to improve our guess of a reasonable window format */
	if (!v4l2_subdev_call(sd, video, g_mbus_fmt, &mf)) {
		icd->user_width		= mf.width;
		icd->user_height	= mf.height;
		icd->colorspace		= mf.colorspace;
		icd->field		= mf.field;
	if (!v4l2_subdev_call(sd, pad, get_fmt, NULL, &fmt)) {
		icd->user_width		= mf->width;
		icd->user_height	= mf->height;
		icd->colorspace		= mf->colorspace;
		icd->field		= mf->field;
	}
	soc_camera_remove_device(icd);


static int soc_camera_platform_s_stream(struct v4l2_subdev *sd, int enable)}

static int soc_camera_platform_fill_fmt(struct v4l2_subdev *sd,
					struct v4l2_mbus_framefmt *mf)
		struct v4l2_subdev_pad_config *cfg,
		struct v4l2_subdev_format *format)
{
	struct soc_camera_platform_info *p = v4l2_get_subdevdata(sd);
	struct v4l2_mbus_framefmt *mf = &format->format;

	mf->width	= p->format.width;
	mf->height	= p->format.height;

static struct v4l2_subdev_video_ops platform_subdev_video_ops = {	.s_stream	= soc_camera_platform_s_stream,
	.cropcap	= soc_camera_platform_cropcap,
	.g_crop		= soc_camera_platform_g_crop,
	.try_mbus_fmt	= soc_camera_platform_fill_fmt,
	.g_mbus_fmt	= soc_camera_platform_fill_fmt,
	.s_mbus_fmt	= soc_camera_platform_fill_fmt,
	.g_mbus_config	= soc_camera_platform_g_mbus_config,
};

static const struct v4l2_subdev_pad_ops platform_subdev_pad_ops = {
	.enum_mbus_code = soc_camera_platform_enum_mbus_code,
	.get_fmt	= soc_camera_platform_fill_fmt,
	.set_fmt	= soc_camera_platform_fill_fmt,
};

static struct v4l2_subdev_ops platform_subdev_ops = {

struct v4l2_mbus_frame_desc {
   g_dv_timings(): Get custom dv timings in the sub device.

   g_mbus_fmt: get the current pixel format, provided by a video data source

   try_mbus_fmt: try to set a pixel format on a video data source

   s_mbus_fmt: set a pixel format on a video data source

struct v4l2_subdev_video_ops {			struct v4l2_dv_timings *timings);
	int (*query_dv_timings)(struct v4l2_subdev *sd,
			struct v4l2_dv_timings *timings);
	int (*g_mbus_fmt)(struct v4l2_subdev *sd,
			  struct v4l2_mbus_framefmt *fmt);
	int (*try_mbus_fmt)(struct v4l2_subdev *sd,
			    struct v4l2_mbus_framefmt *fmt);
	int (*s_mbus_fmt)(struct v4l2_subdev *sd,


